-- ====================================================================================
-- SCRIPT MAESTRO DEFINITIVO DE BASE DE DATOS PARA NICEPOD / NICEHIVE
-- Versión: 13.0 (Producción, Idempotente y Auto-Contenido)
-- Descripción: Versión final que incluye una sección de demolición completa y explícita,
-- garantizando que se pueda ejecutar de forma segura en cualquier entorno.
-- ====================================================================================


-- ========= SECCIÓN 0: DEMOLICIÓN SEGURA Y COMPLETA (RESET) =========
-- Elimina todos los objetos en el orden de dependencia correcto para asegurar un estado limpio.

-- Paso 1: Eliminar las tablas. CASCADE se encarga de políticas, triggers e índices.
DROP TABLE IF EXISTS public.podcast_creation_jobs CASCADE;
DROP TABLE IF EXISTS public.ai_prompts CASCADE;
DROP TABLE IF EXISTS public.micro_pods CASCADE;
DROP TABLE IF EXISTS public.subscriptions CASCADE;
DROP TABLE IF EXISTS public.plans CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- Paso 2: Eliminar las funciones personalizadas.
DROP FUNCTION IF EXISTS public.increment_jobs_and_queue(UUID, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.create_profile_and_free_subscription() CASCADE;
DROP FUNCTION IF EXISTS public.handle_updated_at() CASCADE;
DROP FUNCTION IF EXISTS public.get_current_uid() CASCADE;

-- Paso 3: Eliminar los tipos de datos personalizados (ENUMs).
DROP TYPE IF EXISTS public.job_status;
DROP TYPE IF EXISTS public.podcast_status;
DROP TYPE IF EXISTS public.subscription_status;


-- ========= SECCIÓN 1: HABILITAR EXTENSIONES REQUERIDAS =========
CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA extensions;


-- ========= SECCIÓN 2: TIPOS DE DATOS PERSONALIZADOS (ENUMS) =========
CREATE TYPE public.subscription_status AS ENUM ('active', 'inactive', 'trialing', 'past_due');
CREATE TYPE public.podcast_status AS ENUM ('pending_approval', 'published', 'archived', 'failed');
CREATE TYPE public.job_status AS ENUM ('pending', 'processing', 'completed', 'failed');


-- ========= SECCIÓN 3: CREACIÓN DE TABLAS PRINCIPALES =========
CREATE TABLE public.profiles ( id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE, username TEXT UNIQUE NOT NULL CHECK (char_length(username) >= 3), full_name TEXT, avatar_url TEXT, role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('user', 'admin')), active_creation_jobs INTEGER NOT NULL DEFAULT 0 CHECK (active_creation_jobs >= 0), stripe_customer_id TEXT UNIQUE, created_at TIMESTAMPTZ NOT NULL DEFAULT now(), updated_at TIMESTAMPTZ NOT NULL DEFAULT now() );
CREATE TABLE public.plans ( id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, active BOOLEAN NOT NULL DEFAULT true, name TEXT NOT NULL UNIQUE, description TEXT, price_monthly NUMERIC(10, 2), monthly_creation_limit INTEGER NOT NULL DEFAULT 0 CHECK (monthly_creation_limit >= 0), features TEXT[] );
CREATE TABLE public.subscriptions ( user_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE, plan_id BIGINT NOT NULL REFERENCES public.plans(id), status subscription_status NOT NULL DEFAULT 'active', stripe_subscription_id TEXT UNIQUE, current_period_end TIMESTAMPTZ, created_at TIMESTAMPTZ NOT NULL DEFAULT now(), updated_at TIMESTAMPTZ NOT NULL DEFAULT now() );
CREATE TABLE public.micro_pods ( id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE, title TEXT NOT NULL CHECK (char_length(title) > 0), description TEXT, script_text TEXT, audio_url TEXT, cover_image_url TEXT, duration_seconds INT, category TEXT, status podcast_status NOT NULL DEFAULT 'pending_approval', play_count BIGINT NOT NULL DEFAULT 0, like_count BIGINT NOT NULL DEFAULT 0, created_at TIMESTAMPTZ NOT NULL DEFAULT now(), updated_at TIMESTAMPTZ NOT NULL DEFAULT now() );
CREATE TABLE public.ai_prompts ( id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, agent_name TEXT NOT NULL UNIQUE, description TEXT, prompt_template TEXT NOT NULL, prompt_variables TEXT[] NULL );
CREATE TABLE public.podcast_creation_jobs ( id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE, status job_status NOT NULL DEFAULT 'pending', payload JSONB, error_message TEXT, retry_count INT NOT NULL DEFAULT 0, micro_pod_id BIGINT NULL REFERENCES public.micro_pods(id) ON DELETE SET NULL, archived BOOLEAN NOT NULL DEFAULT false, created_at TIMESTAMPTZ NOT NULL DEFAULT now(), updated_at TIMESTAMPTZ NOT NULL DEFAULT now(), job_title TEXT GENERATED ALWAYS AS ( CASE WHEN payload->>'style' = 'solo' THEN payload->'inputs'->>'topic' WHEN payload->>'style' = 'link' THEN payload->'inputs'->'narrative'->>'title' ELSE 'Untitled Job' END ) STORED );


-- ========= SECCIÓN 4: ÍNDICES PARA OPTIMIZACIÓN DE RENDIMIENTO =========
CREATE INDEX IF NOT EXISTS idx_micro_pods_user_id ON public.micro_pods(user_id);
CREATE INDEX IF NOT EXISTS idx_micro_pods_status ON public.micro_pods(status);
CREATE INDEX IF NOT EXISTS idx_jobs_user_id ON public.podcast_creation_jobs(user_id);
CREATE INDEX IF NOT EXISTS idx_jobs_status ON public.podcast_creation_jobs(status);


-- ========= SECCIÓN 5: LÓGICA DE NEGOCIO (TRIGGERS Y FUNCIONES) =========
CREATE OR REPLACE FUNCTION public.handle_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = now(); RETURN NEW; END; $$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';
CREATE OR REPLACE FUNCTION public.get_current_uid() RETURNS UUID AS $$ SELECT auth.uid(); $$ LANGUAGE sql STABLE SECURITY DEFINER SET search_path = '';
CREATE OR REPLACE FUNCTION public.create_profile_and_free_subscription() RETURNS TRIGGER AS $$ DECLARE free_plan_id BIGINT; BEGIN SELECT id INTO free_plan_id FROM public.plans WHERE name = 'Gratuito' LIMIT 1; IF free_plan_id IS NULL THEN RAISE EXCEPTION 'Plan "Gratuito" no encontrado.'; END IF; INSERT INTO public.profiles (id, username, full_name, avatar_url, role) VALUES (NEW.id, COALESCE(NEW.raw_user_meta_data->>'user_name', NEW.id::text), NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'avatar_url', 'user'); INSERT INTO public.subscriptions (user_id, plan_id, status) VALUES (NEW.id, free_plan_id, 'active'); UPDATE auth.users SET raw_app_meta_data = raw_app_meta_data || jsonb_build_object('user_role', 'user') WHERE id = NEW.id; RETURN NEW; END; $$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';
CREATE OR REPLACE FUNCTION public.increment_jobs_and_queue(p_user_id UUID, p_payload JSONB) RETURNS BIGINT LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$ DECLARE new_job_id BIGINT; BEGIN UPDATE public.profiles SET active_creation_jobs = active_creation_jobs + 1 WHERE id = p_user_id; INSERT INTO public.podcast_creation_jobs (user_id, payload) VALUES (p_user_id, p_payload) RETURNING podcast_creation_jobs.id INTO new_job_id; RETURN new_job_id; END; $$;
CREATE TRIGGER on_profiles_update BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_subscriptions_update BEFORE UPDATE ON public.subscriptions FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_micro_pods_update BEFORE UPDATE ON public.micro_pods FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_jobs_update BEFORE UPDATE ON public.podcast_creation_jobs FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_new_user_setup AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.create_profile_and_free_subscription();


-- ========= SECCIÓN 6: SEGURIDAD (ROW LEVEL SECURITY - RLS) =========
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.micro_pods ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.podcast_creation_jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ai_prompts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Los usuarios pueden gestionar su propio perfil." ON public.profiles FOR ALL USING (public.get_current_uid() = id) WITH CHECK (public.get_current_uid() = id);
CREATE POLICY "Los usuarios pueden ver su propia suscripción." ON public.subscriptions FOR SELECT USING (public.get_current_uid() = user_id);
CREATE POLICY "Acceso general a micro_pods." ON public.micro_pods FOR ALL USING ( status = 'published' OR public.get_current_uid() = user_id ) WITH CHECK ( public.get_current_uid() = user_id );
CREATE POLICY "Los propietarios pueden ver sus propios trabajos de creación." ON public.podcast_creation_jobs FOR SELECT USING (public.get_current_uid() = user_id);
CREATE POLICY "Los usuarios autenticados pueden ver los planes." ON public.plans FOR SELECT USING (public.get_current_uid() IS NOT NULL);
CREATE POLICY "Los administradores pueden ver todos los perfiles." ON public.profiles FOR SELECT USING ((auth.jwt()->>'app_metadata')::jsonb->>'user_role' = 'admin');
CREATE POLICY "Los administradores pueden ver todos los trabajos de creación." ON public.podcast_creation_jobs FOR SELECT USING ((auth.jwt()->>'app_metadata')::jsonb->>'user_role' = 'admin');
CREATE POLICY "Los administradores pueden ver todos los micro-pods." ON public.micro_pods FOR SELECT USING ((auth.jwt()->>'app_metadata')::jsonb->>'user_role' = 'admin');
CREATE POLICY "Los administradores pueden gestionar los prompts de IA." ON public.ai_prompts FOR ALL USING ((auth.jwt()->>'app_metadata')::jsonb->>'user_role' = 'admin');


-- ========= SECCIÓN 7: PERMISOS ENTRE ESQUEMAS =========
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.create_profile_and_free_subscription() TO supabase_auth_admin;
GRANT SELECT ON TABLE public.plans TO supabase_auth_admin;
GRANT INSERT, SELECT ON TABLE public.profiles TO supabase_auth_admin;
GRANT INSERT, SELECT ON TABLE public.subscriptions TO supabase_auth_admin;


-- ========= SECCIÓN 8: DATOS INICIALES (SEEDING) =========
INSERT INTO public.plans (name, description, price_monthly, monthly_creation_limit, features) VALUES ('Gratuito', 'Para empezar a explorar y crear', 0, 5, '{"Creación de guiones por IA", "Acceso a la biblioteca pública"}'), ('Pensador', 'Para el aficionado comprometido que crea con frecuencia', 9.99, 30, '{"Límite de creación extendido", "Panel de analíticas básicas"}'), ('Creador', 'Para el profesional que usa NicePod como herramienta de trabajo', 29.99, 100, '{"Límite de creación masivo", "Analíticas avanzadas", "Soporte prioritario"}') ON CONFLICT (name) DO NOTHING;
INSERT INTO public.ai_prompts (agent_name, description, prompt_template) VALUES ('solo-talk-narrator', 'Un agente experto en storytelling que convierte un tema en una historia cautivadora.', 'Eres un guionista galardonado...'), ('solo-talk-analyst', 'Un agente experto en análisis que desglosa un tema de forma lógica y estructurada.', 'Eres un analista de sistemas y divulgador experto...'), ('link-points-synthesizer', 'Un agente que encuentra la conexión y la armonía entre dos ideas.', 'Eres un pensador de sistemas y un "sintetizador" de ideas...'), ('link-points-catalyst', 'Un agente que usa la tensión entre dos ideas para forjar una tercera.', 'Eres un estratega disruptivo y un experto en pensamiento dialéctico...') ON CONFLICT (agent_name) DO UPDATE SET description = EXCLUDED.description, prompt_template = EXCLUDED.prompt_template;