-- ====================================================================================
-- SCRIPT MAESTRO DEFINITIVO DE BASE DE DATOS PARA NICEPOD
-- Versión: 6.0 (Consolidada y Definitiva)
-- Descripción: Este script establece el esquema inicial completo, incorporando
-- todas las mejores prácticas, optimizaciones y correcciones de seguridad descubiertas.
-- Incluye la función RPC 'increment_jobs_and_queue' requerida por el backend.
-- ====================================================================================


-- ========= SECCIÓN 1: TIPOS DE DATOS PERSONALIZADOS (ENUMS) =========
-- Propósito: Garantizar la integridad referencial y prevenir errores de datos.

CREATE TYPE public.subscription_status AS ENUM ('active', 'inactive', 'trialing', 'past_due');
CREATE TYPE public.podcast_status AS ENUM ('pending_approval', 'published', 'archived', 'failed');
CREATE TYPE public.job_status AS ENUM ('pending', 'processing', 'completed', 'failed');


-- ========= SECCIÓN 2: CREACIÓN DE TABLAS PRINCIPALES =========
-- Propósito: Definir la estructura fundamental de almacenamiento de datos.

CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE NOT NULL CHECK (char_length(username) >= 3),
  full_name TEXT,
  avatar_url TEXT,
  role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('user', 'admin')),
  active_creation_jobs INTEGER NOT NULL DEFAULT 0 CHECK (active_creation_jobs >= 0),
  stripe_customer_id TEXT UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.profiles IS 'Almacena datos públicos y metadatos de los usuarios.';

CREATE TABLE public.plans (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  active BOOLEAN NOT NULL DEFAULT true,
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  price_monthly NUMERIC(10, 2),
  monthly_creation_limit INTEGER NOT NULL DEFAULT 0 CHECK (monthly_creation_limit >= 0),
  features TEXT[]
);
COMMENT ON TABLE public.plans IS 'Define los diferentes niveles de suscripción disponibles.';

CREATE TABLE public.subscriptions (
  user_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  plan_id BIGINT NOT NULL REFERENCES public.plans(id),
  status subscription_status NOT NULL DEFAULT 'active',
  stripe_subscription_id TEXT UNIQUE,
  current_period_end TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.subscriptions IS 'Vincula a un usuario con un plan específico.';

CREATE TABLE public.micro_pods (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL CHECK (char_length(title) > 0),
  description TEXT,
  script_text TEXT,
  audio_url TEXT,
  cover_image_url TEXT,
  duration_seconds INT CHECK (duration_seconds IS NULL OR duration_seconds >= 0),
  category TEXT,
  status podcast_status NOT NULL DEFAULT 'pending_approval',
  play_count BIGINT NOT NULL DEFAULT 0 CHECK (play_count >= 0),
  like_count BIGINT NOT NULL DEFAULT 0 CHECK (like_count >= 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.micro_pods IS 'Contiene los metadatos y contenido de cada micro-podcast.';

CREATE TABLE public.ai_prompts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  agent_name TEXT NOT NULL UNIQUE,
  description TEXT,
  prompt_template TEXT NOT NULL,
  prompt_variables TEXT[] NULL
);
COMMENT ON TABLE public.ai_prompts IS 'Almacena las plantillas de prompts para los agentes de IA.';

CREATE TABLE public.podcast_creation_jobs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  status job_status NOT NULL DEFAULT 'pending',
  payload JSONB,
  error_message TEXT,
  retry_count INT NOT NULL DEFAULT 0 CHECK (retry_count >= 0),
  micro_pod_id BIGINT NULL REFERENCES public.micro_pods(id) ON DELETE SET NULL,
  archived BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  job_title TEXT GENERATED ALWAYS AS (
    CASE
      WHEN payload->>'style' = 'solo' THEN payload->'inputs'->>'topic'
      WHEN payload->>'style' = 'link' THEN payload->'inputs'->'narrative'->>'title'
      ELSE 'Untitled Job'
    END
  ) STORED
);
COMMENT ON TABLE public.podcast_creation_jobs IS 'Cola de trabajos para la creación asíncrona de podcasts.';


-- ========= SECCIÓN 3: ÍNDICES PARA OPTIMIZACIÓN DE RENDIMIENTO =========
CREATE INDEX idx_micro_pods_user_id ON public.micro_pods(user_id);
CREATE INDEX idx_micro_pods_status ON public.micro_pods(status);
CREATE INDEX idx_jobs_user_id ON public.podcast_creation_jobs(user_id);
CREATE INDEX idx_jobs_status ON public.podcast_creation_jobs(status);
CREATE INDEX idx_jobs_archived ON public.podcast_creation_jobs(archived);


-- ========= SECCIÓN 4: LÓGICA DE NEGOCIO (TRIGGERS Y FUNCIONES) =========
CREATE OR REPLACE FUNCTION public.handle_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = now(); RETURN NEW; END; $$ LANGUAGE plpgsql;
CREATE TRIGGER on_profiles_update BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_subscriptions_update BEFORE UPDATE ON public.subscriptions FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_micro_pods_update BEFORE UPDATE ON public.micro_pods FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_jobs_update BEFORE UPDATE ON public.podcast_creation_jobs FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- Función de Onboarding para nuevos usuarios
CREATE OR REPLACE FUNCTION public.create_profile_and_free_subscription()
RETURNS TRIGGER AS $$
DECLARE
  free_plan_id BIGINT;
BEGIN
  SELECT id INTO free_plan_id FROM public.plans WHERE name = 'Gratuito' LIMIT 1;
  IF free_plan_id IS NULL THEN RAISE EXCEPTION 'Plan "Gratuito" no encontrado.'; END IF;
  INSERT INTO public.profiles (id, username, full_name, avatar_url)
  VALUES (NEW.id, COALESCE(NEW.raw_user_meta_data->>'user_name', NEW.id::text), NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'avatar_url');
  INSERT INTO public.subscriptions (user_id, plan_id, status) VALUES (NEW.id, free_plan_id, 'active');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';

-- Trigger que ejecuta la función de onboarding
CREATE TRIGGER on_new_user_setup AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.create_profile_and_free_subscription();

-- **NUEVA FUNCIÓN REQUERIDA**
-- Función RPC para encolar un trabajo de forma segura y atómica.
CREATE OR REPLACE FUNCTION public.increment_jobs_and_queue(p_user_id UUID, p_payload JSONB)
RETURNS void AS $$
BEGIN
  UPDATE public.profiles SET active_creation_jobs = active_creation_jobs + 1 WHERE id = p_user_id;
  INSERT INTO public.podcast_creation_jobs (user_id, payload) VALUES (p_user_id, p_payload);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';


-- ========= SECCIÓN 5: SEGURIDAD (ROW LEVEL SECURITY - RLS) =========
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.micro_pods ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.podcast_creation_jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ai_prompts ENABLE ROW LEVEL SECURITY;

-- POLÍTICAS:
CREATE POLICY "Los usuarios pueden gestionar su propio perfil." ON public.profiles FOR ALL USING (auth.uid() = id);
CREATE POLICY "Los usuarios pueden ver su propia suscripción." ON public.subscriptions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Cualquiera puede ver los podcasts publicados." ON public.micro_pods FOR SELECT USING (status = 'published');
CREATE POLICY "Los propietarios pueden gestionar sus propios podcasts." ON public.micro_pods FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Los propietarios pueden ver sus propios trabajos de creación." ON public.podcast_creation_jobs FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Los administradores pueden gestionar los prompts de IA." ON public.ai_prompts FOR ALL USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin') WITH CHECK ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin');


-- ========= SECCIÓN 6: DATOS INICIALES (SEEDING) =========
INSERT INTO public.plans (name, description, monthly_creation_limit, features)
VALUES ('Gratuito', 'Para empezar a explorar y crear', 5, '{"Creación de guiones por IA", "Acceso a la biblioteca pública"}')
ON CONFLICT (name) DO NOTHING;